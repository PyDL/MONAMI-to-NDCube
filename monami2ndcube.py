#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""

Name: monami2ndcube

@author: Jiajia Liu

Description: Convert the output of potential field extrapolation used in
             NONAMI into NDCube used in SunPy. If only fits file is given
             and potential field extrapolation result is missing, the
             potential magnetic field extrapolation will be calculated.

"""
__author__ = 'Jiajia Liu'
__copyright__ = 'Copyright 2019, The Solar Physics and Space Plasma ' + \
                'Research Center (SP2RC)'
__license__ = 'GPLv3'
__version__ = '1.0'
__maintainor__ = 'Jiajia Liu'
__email__ = 'jj.liu@sheffield.ac.uk'

from scipy.io import readsav
import numpy as np
from astropy.io import fits
import astropy.wcs as wcs
import astropy.units as u
from astropy.coordinates import SkyCoord
from sunpy.coordinates import frames
from ndcube import NDCube
from datetime import datetime
from matplotlib import pyplot as plt
from pfe import Magnetic_Field_Extrapolation


def read_data(obs="example.fits.gz", pf="example.sav", header=None):
    """
    Read IDL sav file which stores the potential field extrapolation generated
    by MONAMI

    Parameters
    ----------
    obs: `string`
        fits file of the original observation
    pf : `string`
        file which stores the extrapolation result generated by MONAMI
    header: fits header
        if is not None, then header will be used instead of the obs

    Returns
    -------
    `dictionary`
        Python dictionary which stores exactly the same information as the
        IDL sav file, with keys:
            bpx: 3d magnetic field, nz x ny x nx, stores the x-component
            bpy: 3d magnetic field, nz x ny x nx, stores the y-component
            bpz: 3d magnetic field, nz x ny x nx, stores the z-component
            header: fits header
            xrange: pixel range of the region in the original image in x
                    direction
            yrange: pixel range of the region in the original image in y
                    direction
    """

    if header is None:
        # read fits file and get the fits header
        hdul = fits.open(obs)
        header = hdul[0].header
        hdul.close()

    # read the IDL save file
    data = readsav(pf)

    # mangetic field
    bpx = np.array(data['bp'][0][0], dtype=float)
    bpy = np.array(data['bp'][0][1], dtype=float)
    bpz = np.array(data['bp'][0][2], dtype=float)

    # zscale
    zscale = data['bp'][0][3]

    # xrange & yrange
    xrange = data['xrange']
    yrange = data['yrange']

    # construct bp dictionary
    bp = {"bpx": bpx, "bpy": bpy, "bpz": bpz, "zscale": zscale,
          "xrange": xrange, "yrange": yrange, "header": header}

    return bp


def construct_wcs(bp):
    """
    Given the result returned by read_data, construct the wcs dictionary for
    the NDCube

    Parameters
    ----------
    result : `dictionary`
        dictionary returned by read_data

    Returns
    -------
    `dictionary`
        wcs dictionary which will be used for generating the NDCube
    """
    header = bp["header"]
    xrange = bp["xrange"]
    yrange = bp["yrange"]
    zscale = bp["zscale"]
    shape = np.shape(bp["bpx"])
    crval1 = (np.mean(xrange) - header['crpix1']) * header['cdelt1']
    crval2 = (np.mean(yrange) - header['crpix2']) * header['cdelt2']

    # estimate approximating cdelt3 for z-direction
    # Only gives precise approximation when the active region is near disk
    # center. Anyway, the field extrapolation also gives good results only
    # when the active region is near disk
    t_obs = header['t_obs'][0:19]
    t_obs = datetime.strptime(t_obs, '%Y.%m.%d_%H:%M:%S')
    coord = SkyCoord(header['cdelt1']*u.arcsec, header['cdelt2']*u.arcsec,
                     frame=frames.Helioprojective, obstime=t_obs)
    cdelt3 = ((coord.cartesian.z * u.au).to(u.km)).value
    wcs_dict = {
        'CTYPE1': 'HPLT-TAN',
                  'CUNIT1': header['cunit1'],
                  'CDELT1': header['cdelt1'],
                  'CRPIX1': shape[2] / 2. - 1,
                  'NAXIS1': shape[2],
                  'CRVAL1': crval1,
        'CTYPE2': 'HPLN-TAN',
                  'CUNIT2': header['cunit2'],
                  'CDELT2': header['cdelt2'],
                  'CRPIX2': shape[1] / 2. - 1,
                  'NAXIS2': shape[1],
                  'CRVAL2': crval2,
        'CTYPE3': 'HPRZ    ',
                  'CUNIT3': 'km',
                  'CDELT3': cdelt3 * zscale,
                  'CRPIX3': 0,
                  'NAXIS3': shape[0],
                  'CRVAL3': 0.0
                      }
    input_wcs = wcs.WCS(wcs_dict)
    return input_wcs


def get_roi(data):
    """
    Plot out the data and select region of interest
    Parameters
    ----------
    data : `list` or `numpy.ndarray`
        LOS magnetic field or Bz
    Returns
    -------
    `tuple`
        with the first and second element as the pixel coordinate of the edges
        of the ROI
    """
    # shape of data
    shape = np.shape(data)
    ans = 'n'
    while ans != 'y' and ans != 'Y':
        # create figure
        fig, ax = plt.subplots(figsize=(8, 8*shape[0]/shape[1]))
        # show the photospheric magnetic field
        ax.imshow(data, vmin=-800, vmax=800, origin='lower')
        # set lables and title
        ax.set_xlabel('X (pix)')
        ax.set_ylabel('Y (pix)')
        ax.set_title('Please use the zoom tool to select your region' +
                     ' of interest!')
        # set axes range
        ax.set_xlim([0, shape[1]-1])
        ax.set_ylim([0, shape[0]-1])
        # show the image
        plt.show(block=True)
        # get axes range
        xrange = ax.get_xlim()
        yrange = ax.get_ylim()
        # convert to integer
        xrange = np.rint(xrange).tolist()
        yrange = np.rint(yrange).tolist()
        xrange = list(map(int, xrange))
        yrange = list(map(int, yrange))
        # not beyond the boudnary
        if xrange[1] >= shape[1]:
            xrange[1] = shape[1] - 1
        if yrange[1] >= shape[0]:
            yrange[1] = shape[0] - 1
        # make pixel numbers even
        if (yrange[1] - yrange[0]) % 2 == 1:
            yrange[1] = yrange[1] - 1
        if (xrange[1] - xrange[0]) % 2 == 1:
            xrange[1] = xrange[1] - 1
        if xrange[0] == 0 and yrange[0] == 0 and xrange[1] == shape[1]-1 \
            and yrange[1] == shape[0]-1:
               print("You did not select a region of interest!")
               ans = 'n'
        else:
            print(('Your region of interest is: x [{:4d}, {:4d}]' +
                   ' and y [{:4d}, {:4d}]').format(xrange[0], xrange[1],
                                                   yrange[0], yrange[1]))
            ans = input('Are you happy with the selected region? Y/N:')

    return xrange, yrange


def generate_ndcube(obs="example.fits.gz", pf=None, bp=None, input_wcs=None,
                    zscale=1, nz=30, finite_energy=True,
                    xrange=None, yrange=None):
    """
    Generate NDCubes from the potential field extrapolation generated by
    MONAMI
    Parameters
    ----------
    obs : `string`
        file name of the fits file of the observation
    pf : `string`
        file name of the field extrapolation result
    bp : `dictionary`
        output of function read_data(obs, pf)
    input_wcs : `astropy.wcs.WCS`
        output of funciton construct_wcs(bp)
    zscale: `int`
        Sets the z-scale (1 = same scale as the x,y axes before the
        heliographic transformation). Default= 1
    nz: `int`
        Number of equally spaced grid points in the z direction
    finite_energy: `bool`
        whether or not to constrain with finite energy
    xrange, yrange: `list`
        with 2 elements, defines the edges of the ROI where the potential field
        extrapolation will be performed
    Returns
    -------
    `tuple`
        with the first, second and third element as the NDCube for bxp, byp
        and bzp

    """
    # read data
    if bp is None:
        if pf is not None:
            bp = read_data(obs, pf)
        else:
            # read fits file and get the fits header
            hdul = fits.open(obs)
            header = hdul[0].header
            bz = hdul[0].data
            hdul.close()
            shape = np.shape(bz)

            # get xrange and yrange
            if xrange is None or yrange is None:
                xrange, yrange = get_roi(bz)
            # test if xrange and yrange is correct
            if np.shape(xrange) != (2,):
                raise ValueError("xrange must be in form of [x0, x1]!")
            if np.shape(yrange) != (2,):
                raise ValueError("yrange must be in form of [x0, x1]!")
            # convert xrange and yrange into integers
            xrange = np.rint(xrange).tolist()
            yrange = np.rint(yrange).tolist()
            xrange = list(map(int, xrange))
            yrange = list(map(int, yrange))
            # not beyond the boudnary
            if xrange[1] >= shape[1]:
                xrange[1] = shape[1] - 1
            if yrange[1] >= shape[0]:
                yrange[1] = shape[0] - 1
            if xrange[0] < 0:
                xrange[0] = 0
            if yrange[0] < 0:
                yrange[0] = 0

            # make pixel numbers even
            if (yrange[1] - yrange[0]) % 2 == 1:
                yrange[1] = yrange[1] - 1
            if (xrange[1] - xrange[0]) % 2 == 1:
                xrange[1] = xrange[1] - 1
            
            # call the potential field extrapolation code
            print('Start to perform the potential field extrapolation...')
            pfe = Magnetic_Field_Extrapolation(
                  bz[yrange[0]:yrange[1], xrange[0]:xrange[1]], nz=nz,
                  zscale=zscale, finite_energy=finite_energy)

            # construct bp dictionary
            bp = {"bpx": pfe['Bx'], "bpy": pfe['By'], "bpz": pfe['Bz'],
                  "zscale": zscale, "xrange": xrange, "yrange": yrange,
                  "header": header}

    # construct wcs coordinate
    if input_wcs is None:
        input_wcs = construct_wcs(bp)

    # create NDCubes
    bxtube = NDCube(bp['bpx'], input_wcs)
    bytube = NDCube(bp['bpy'], input_wcs)
    bztube = NDCube(bp['bpz'], input_wcs)

    return (bxtube, bytube, bztube)
